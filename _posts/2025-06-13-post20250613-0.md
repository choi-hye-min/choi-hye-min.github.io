---
layout: post
title: "Kotlin 코루틴 스코프 종류와 활용법: 상황별 실전 예제"
date: 2025-06-13 19:46:04 +0900
categories: [Kotlin, Coroutine]
tags: [kotlin, coroutine, scope, async, launch, structuredconcurrency]
---

> 코루틴 스코프의 종류와 각각의 특징, 그리고 실제로 어떤 상황에서 어떤 스코프를 사용하면 좋은지 초보자도 이해할 수 있도록 다양한 예제와 함께 정리합니다.
> 실수하기 쉬운 부분과 실전 패턴, 공식 문서 레퍼런스까지 한 번에 익혀보세요.

---
> 타입 파라미터, 공변성/반공변성, reified, 타입 소거 등 JVM 기반 제네릭의 핵심을 초보자도 이해할 수 있도록 설명합니다.
> 실습 예제와 디자인 패턴, 자바와의 상호 운용성까지 실제 코드와 함께 소개합니다.

#### 들어가며

제네릭은 반복되는 타입별 코드를 줄이고, 타입 안정성을 높이며, 재사용성을 극대화하는 현대 프로그래밍의 핵심 기능입니다. 하지만 JVM 기반 언어에서 제네릭은 타입 소거, 공변성/반공변성, reified 등 다양한 개념이 얽혀 있어 초보자에게 어렵게 느껴질 수 있습니다. 이 포스트에서는 코틀린 제네릭을 체계적으로, 실전 예제와 함께 완벽하게 정리합니다.

---

#### 1단계: 제네릭의 기본 개념 이해

- **제네릭이란?**
  - 타입을 파라미터화하여 재사용 가능한 코드를 작성할 수 있게 해주는 기능입니다.
  - 컴파일 시점에 타입 안정성을 보장하고, 런타임에 ClassCastException을 방지하는 것이 주 목적입니다.

- **타입 파라미터(Type Parameters)**
  - `<T>`, `<E>`, `<K>`, `<V>` 등 관례적으로 사용되는 타입 파라미터의 의미를 익힙니다.
  - 클래스, 인터페이스, 함수에 타입 파라미터를 선언하는 방법을 실습합니다.

- **제네릭 클래스 및 인터페이스**
  - `class Box<T>(val item: T)`와 같이 제네릭 타입을 가지는 클래스를 선언하고 사용하는 방법을 익힙니다.
  - `interface MyList<T>`와 같이 제네릭 인터페이스를 선언하고 구현하는 방법을 실습합니다.

- **제네릭 함수**
  - `fun <T> identity(value: T): T = value`와 같이 함수에 타입 파라미터를 사용하는 방법을 익힙니다.
  - 확장 함수(Extension Function)에도 제네릭을 적용할 수 있습니다.

- **추천 실습**
  - Int, String, 사용자 정의 클래스 등을 저장할 수 있는 제네릭 Box 클래스를 만들어보세요.
  - 두 개의 요소를 받아 쌍으로 반환하는 제네릭 함수를 만들어보세요.
  - 어떤 타입의 리스트라도 출력할 수 있는 제네릭 확장 함수를 만들어보세요.

```kotlin
// 제네릭 클래스 예제
class Box<T>(val item: T)
val intBox = Box(123)
val strBox = Box("hello")

// 제네릭 함수 예제
def <T> pair(a: T, b: T) = Pair(a, b)
val p = pair(1, 2)

// 제네릭 확장 함수 예제
fun <T> List<T>.printAll() = forEach { println(it) }
listOf("a", "b", "c").printAll()
```

---

#### 2단계: 제네릭의 고급 개념 및 활용

- **타입 제약(Type Constraints)**
  - `fun <T : Number> add(a: T, b: T)`와 같이 특정 타입의 서브타입으로만 제한할 수 있습니다.
  - 여러 제약은 `where` 절로 표현합니다.

- **공변성(Covariance) & 반공변성(Contravariance)**
  - `out T`(공변성): 생산자(Producer) 역할, 예: `List<out T>`
  - `in T`(반공변성): 소비자(Consumer) 역할, 예: `Comparator<in T>`
  - `*`(STAR Projection): 타입 파라미터를 모를 때 안전하게 사용

- **reified 타입 파라미터**
  - `inline fun <reified T> printTypeName()`처럼, 런타임에 제네릭 타입 정보를 유지할 수 있습니다.
  - 일반 제네릭 함수에서는 타입 정보가 소거되어 is/as 검사 불가 → reified로 해결

- **타입 소거(Type Erasure)**
  - JVM에서 제네릭 타입 정보는 런타임에 소거되어, is/as 연산자 사용이 불가합니다.
  - reified의 필요성을 이해하고, 한계를 인지합니다.

- **추천 실습**
  - Number 타입만 받을 수 있는 제네릭 스택 클래스를 만들어보세요.
  - Producer<out T>와 Consumer<in T> 인터페이스를 정의해보고, 각각의 리스트를 활용해 공변성과 반공변성의 차이를 실험해보세요.
  - reified 키워드를 사용해 제네릭 함수의 런타임 타입 체크를 해보세요.
  - 타입 소거로 인한 컴파일 에러를 직접 경험해보세요.

```kotlin
// [타입 제약(Type Constraints)]
fun <T : Number> multiply(a: T, b: T): Double = a.toDouble() * b.toDouble()
println(multiply(2, 3)) // 6.0
println(multiply(2.5, 4.0)) // 10.0

// 여러 타입 제약(where 절)
fun <T> printSumIfNumberList(list: List<T>) where T : Number, T : Comparable<T> {
    println(list.sumOf { it.toDouble() })
}
printSumIfNumberList(listOf(1, 2, 3))

// [공변성(Covariance) & 반공변성(Contravariance)]
open class Animal(val name: String)
class Dog(name: String) : Animal(name)

interface Producer<out T> { fun produce(): T }
class DogProducer : Producer<Dog> {
    override fun produce() = Dog("Coco")
}
fun printAnimal(producer: Producer<Animal>) {
    println(producer.produce().name)
}
printAnimal(DogProducer()) // 공변성 덕분에 Producer<Dog>를 Producer<Animal>에 대입 가능

interface Consumer<in T> { fun consume(item: T) }
class AnimalConsumer : Consumer<Animal> {
    override fun consume(item: Animal) = println("Consumed: ${item.name}")
}
fun feedDog(consumer: Consumer<Dog>, dog: Dog) {
    consumer.consume(dog)
}
feedDog(AnimalConsumer(), Dog("Bori")) // 반공변성 덕분에 Consumer<Animal>을 Consumer<Dog>에 대입 가능

// [STAR Projection]
fun printFirst(list: List<*>) {
    println(list.firstOrNull())
}
printFirst(listOf(1, 2, 3))
printFirst(listOf("a", "b"))

// [reified 타입 파라미터]
inline fun <reified T> filterOfType(list: List<Any>): List<T> = list.filterIsInstance<T>()
val mixed = listOf(1, "hi", 2.0, "bye")
println(filterOfType<String>(mixed)) // [hi, bye]

inline fun <reified T> printTypeName() = println(T::class.simpleName)
printTypeName<Double>() // Double

// [타입 소거(Type Erasure) 한계]
fun <T> isString(value: Any): Boolean {
    // return value is T // 컴파일 에러: Cannot check for instance of erased type: T
    return false
}
// 해결: reified를 사용한 인라인 함수로 대체

// [실전: Number 타입만 받는 제네릭 스택]
class NumberStack<T : Number> {
    private val items = mutableListOf<T>()
    fun push(item: T) = items.add(item)
    fun pop(): T? = if (items.isNotEmpty()) items.removeAt(items.size - 1) else null
}
val stack = NumberStack<Int>()
stack.push(10)
stack.push(20)
println(stack.pop()) // 20

// [실전: 공변성/반공변성 실험]
val animalProducers: List<Producer<out Animal>> = listOf(DogProducer())
val animalConsumers: List<Consumer<in Dog>> = listOf(AnimalConsumer())

// [실전: reified로 런타임 타입 체크]
inline fun <reified T> findFirstOfType(list: List<Any>): T? = list.firstOrNull { it is T } as? T
println(findFirstOfType<String>(listOf(1, 2, "hello", 3.0))) // hello
```


---

#### 3단계: 실전 적용 및 디자인 패턴

- **컬렉션 프레임워크와 제네릭**
  - List<T>, Map<K, V>, Set<T> 등 코틀린의 컬렉션 프레임워크가 제네릭을 어떻게 활용하는지 분석합니다.
  - filterIsInstance<T>(), map<T, R>() 등 제네릭 기반의 컬렉션 함수 숙달

- **디자인 패턴에 제네릭 적용**
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val one = async { delay(1000); "첫 번째 결과" }
    val two = async { delay(500); "두 번째 결과" }
    println("모든 작업 시작!")
    // awaitAll을 사용하면 두 작업이 끝날 때까지 기다렸다가 결과를 모읍니다.
    val results = awaitAll(one, two)
    println(results) // [첫 번째 결과, 두 번째 결과]
}
```

> launch는 단순히 작업을 시작할 때, async는 결과가 필요한 동시 작업에 사용하세요.

---

#### 상황별 추천 사용법 & 실수 방지 팁

- **GlobalScope**: 정말 특별한 경우 외에는 사용하지 말 것
- **CoroutineScope**: 커스텀 객체, 싱글톤, 라이브러리 등에서 명확한 스코프 관리가 필요할 때 직접 생성해서 사용
- **MainScope**: UI 컨트롤러에서 메인스레드 작업을 할 때 사용
- **viewModelScope, lifecycleScope**: 안드로이드 앱이라면 무조건 적극 활용 (메모리 누수 방지)
- **항상 스코프의 생명주기와 코루틴의 취소 정책을 고려**

```kotlin
// 잘못된 예시: Activity가 사라져도 코루틴이 살아있는 경우
GlobalScope.launch {
    // Activity가 이미 파괴됐는데도 실행됨 (메모리 누수 위험)
}

// 올바른 예시: lifecycleScope를 사용
lifecycleScope.launch {
    // Activity 종료 시 자동으로 취소됨
}
```

---

#### WebClient/ktor-client 코루틴 실전 예제

코루틴 스코프와 async를 활용하면 여러 비동기 HTTP 요청을 동시에 처리할 수 있습니다. 대표적으로 ktor-client, Spring WebClient 등에서 코루틴을 쉽게 사용할 수 있습니다.

```kotlin
import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.request.*
import kotlinx.coroutines.*

suspend fun fetchUrl(client: HttpClient, url: String): String = client.get(url).bodyAsText()

fun main() = runBlocking {
    val client = HttpClient(CIO)
    val urls = listOf("https://httpbin.org/get", "https://httpbin.org/uuid")
    val results = urls.map { url ->
        async { fetchUrl(client, url) }
    }.awaitAll()
    println(results)
    client.close()
}
```

> 여러 API를 동시에 호출하고 결과를 모으고 싶을 때, launch 대신 async+awaitAll 패턴을 사용하면 효율적입니다.

---

#### 1. GlobalScope

- 앱 전체에서 살아있는 글로벌한 스코프
- 앱이 종료될 때까지 살아있으므로, 메모리 누수 위험이 있음
- **실제로는 거의 권장되지 않음**

```kotlin
GlobalScope.launch {
    // 앱이 종료될 때까지 살아있는 작업
    println("GlobalScope에서 실행")
}
```

> 언제 사용? 정말로 앱 전체 생명주기와 함께해야 하는 백그라운드 작업(예: 로그 수집 등) 외에는 사용 자제

---

#### 2. CoroutineScope

- 커스텀 객체, 싱글톤, 라이브러리 등에서 명확한 스코프 관리가 필요할 때 직접 생성해서 사용
- 스코프의 생명주기를 명확히 관리할 수 있습니다.

```kotlin
val scope = CoroutineScope(Dispatchers.Default)
scope.launch {
    // 스코프가 취소될 때까지 실행
}
scope.cancel() // 스코프 취소
```

> 언제 사용? 명확한 스코프 관리가 필요한 경우, 라이브러리나 싱글톤 객체에서 사용

---

#### 3. MainScope

- UI 컨트롤러에서 메인스레드 작업을 할 때 사용
- 메인스레드에서 실행되므로, UI 업데이트에 사용할 수 있습니다.

```kotlin
import kotlinx.coroutines.MainScope

class MyActivity : AppCompatActivity() {
    private val scope = MainScope()

    override fun onDestroy() {
        super.onDestroy()
        scope.cancel() // 액티비티 종료 시 스코프 취소
    }

    fun doSomething() {
        scope.launch {
            // 메인스레드에서 실행
        }
    }
}
```

> 언제 사용? UI 컨트롤러에서 메인스레드 작업을 할 때

---

#### 4. viewModelScope, lifecycleScope

- 안드로이드 앱이라면 무조건 적극 활용 (메모리 누수 방지)
- 뷰모델이나 라이프사이클 오너에서 사용하면, 자동으로 스코프가 취소됩니다.

```kotlin
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelScope

class MyViewModel : ViewModel() {
    fun doSomething() {
        viewModelScope.launch {
            // 뷰모델이 파괴될 때까지 실행
        }
    }
}
```

> 언제 사용? 뷰모델이나 라이프사이클 오너에서 사용

---

#### 참고 레퍼런스

- 코틀린 공식 문서: [https://kotlinlang.org/docs/reference/coroutines/basics.html](https://kotlinlang.org/docs/reference/coroutines/basics.html)
- 안드로이드 공식 문서: [https://developer.android.com/kotlin/coroutines](https://developer.android.com/kotlin/coroutines)

---

#### 학습 팁

- 이론 학습 후 즉시 실습: 개념만으로는 제네릭을 완전히 이해하기 어렵습니다. 직접 코드로 구현해보며 손에 익히세요.
- 다양한 예제 코드 분석: 코틀린 공식 문서, 오픈소스, 유명 라이브러리에서 제네릭 활용 사례를 찾아보세요.
- "왜?"라는 질문 던지기: 특정 문법/패턴이 왜 필요한지, 어떤 문제를 해결하는지 고민하세요.
- 점진적 학습: 쉬운 개념부터 차근차근 쌓아가세요.

---

> 코틀린 제네릭을 제대로 이해하면, 더 안전하고 유연하며 재사용성 높은 코드를 작성할 수 있습니다. 실습과 질문을 반복하며 자신만의 노하우를 쌓아보세요!
