---
layout: post
title: "Kotlin 제네릭 완전 정복: 기본부터 실전, 고급 활용까지"
date: 2025-06-13 01:14:53 +0900
categories: [Kotlin, Generics, Programming]
tags: [kotlin, generics, 타입파라미터, 코틀린, 디자인패턴]
---

> 코틀린 제네릭의 기본 개념부터 고급 활용, 실전 패턴, 트러블슈팅까지 한 번에 정리합니다.
> 타입 파라미터, 공변성/반공변성, reified, 타입 소거 등 JVM 기반 제네릭의 핵심을 초보자도 이해할 수 있도록 설명합니다.
> 실습 예제와 디자인 패턴, 자바와의 상호 운용성까지 실제 코드와 함께 소개합니다.

#### 들어가며

제네릭은 반복되는 타입별 코드를 줄이고, 타입 안정성을 높이며, 재사용성을 극대화하는 현대 프로그래밍의 핵심 기능입니다. 하지만 JVM 기반 언어에서 제네릭은 타입 소거, 공변성/반공변성, reified 등 다양한 개념이 얽혀 있어 초보자에게 어렵게 느껴질 수 있습니다. 이 포스트에서는 코틀린 제네릭을 체계적으로, 실전 예제와 함께 완벽하게 정리합니다.

---

#### 1단계: 제네릭의 기본 개념 이해

- **제네릭이란?**
  - 타입을 파라미터화하여 재사용 가능한 코드를 작성할 수 있게 해주는 기능입니다.
  - 컴파일 시점에 타입 안정성을 보장하고, 런타임에 ClassCastException을 방지하는 것이 주 목적입니다.

- **타입 파라미터(Type Parameters)**
  - `<T>`, `<E>`, `<K>`, `<V>` 등 관례적으로 사용되는 타입 파라미터의 의미를 익힙니다.
  - 클래스, 인터페이스, 함수에 타입 파라미터를 선언하는 방법을 실습합니다.

- **제네릭 클래스 및 인터페이스**
  - `class Box<T>(val item: T)`와 같이 제네릭 타입을 가지는 클래스를 선언하고 사용하는 방법을 익힙니다.
  - `interface MyList<T>`와 같이 제네릭 인터페이스를 선언하고 구현하는 방법을 실습합니다.

- **제네릭 함수**
  - `fun <T> identity(value: T): T = value`와 같이 함수에 타입 파라미터를 사용하는 방법을 익힙니다.
  - 확장 함수(Extension Function)에도 제네릭을 적용할 수 있습니다.

- **추천 실습**
  - Int, String, 사용자 정의 클래스 등을 저장할 수 있는 제네릭 Box 클래스를 만들어보세요.
  - 두 개의 요소를 받아 쌍으로 반환하는 제네릭 함수를 만들어보세요.
  - 어떤 타입의 리스트라도 출력할 수 있는 제네릭 확장 함수를 만들어보세요.

```kotlin
// 제네릭 클래스 예제
class Box<T>(val item: T)
val intBox = Box(123)
val strBox = Box("hello")

// 제네릭 함수 예제
def <T> pair(a: T, b: T) = Pair(a, b)
val p = pair(1, 2)

// 제네릭 확장 함수 예제
fun <T> List<T>.printAll() = forEach { println(it) }
listOf("a", "b", "c").printAll()
```

---

#### 2단계: 제네릭의 고급 개념 및 활용

- **타입 제약(Type Constraints)**
  - `fun <T : Number> add(a: T, b: T)`와 같이 특정 타입의 서브타입으로만 제한할 수 있습니다.
  - 여러 제약은 `where` 절로 표현합니다.

- **공변성(Covariance) & 반공변성(Contravariance)**
  - `out T`(공변성): 생산자(Producer) 역할, 예: `List<out T>`
  - `in T`(반공변성): 소비자(Consumer) 역할, 예: `Comparator<in T>`
  - `*`(STAR Projection): 타입 파라미터를 모를 때 안전하게 사용

- **reified 타입 파라미터**
  - `inline fun <reified T> printTypeName()`처럼, 런타임에 제네릭 타입 정보를 유지할 수 있습니다.
  - 일반 제네릭 함수에서는 타입 정보가 소거되어 is/as 검사 불가 → reified로 해결

- **타입 소거(Type Erasure)**
  - JVM에서 제네릭 타입 정보는 런타임에 소거되어, is/as 연산자 사용이 불가합니다.
  - reified의 필요성을 이해하고, 한계를 인지합니다.

- **추천 실습**
  - Number 타입만 받을 수 있는 제네릭 스택 클래스를 만들어보세요.
  - Producer<out T>와 Consumer<in T> 인터페이스를 정의해보고, 각각의 리스트를 활용해 공변성과 반공변성의 차이를 실험해보세요.
  - reified 키워드를 사용해 제네릭 함수의 런타임 타입 체크를 해보세요.
  - 타입 소거로 인한 컴파일 에러를 직접 경험해보세요.

```kotlin
// [타입 제약(Type Constraints)]
fun <T : Number> multiply(a: T, b: T): Double = a.toDouble() * b.toDouble()
println(multiply(2, 3)) // 6.0
println(multiply(2.5, 4.0)) // 10.0

// 여러 타입 제약(where 절)
fun <T> printSumIfNumberList(list: List<T>) where T : Number, T : Comparable<T> {
    println(list.sumOf { it.toDouble() })
}
printSumIfNumberList(listOf(1, 2, 3))

// [공변성(Covariance) & 반공변성(Contravariance)]
open class Animal(val name: String)
class Dog(name: String) : Animal(name)

interface Producer<out T> { fun produce(): T }
class DogProducer : Producer<Dog> {
    override fun produce() = Dog("Coco")
}
fun printAnimal(producer: Producer<Animal>) {
    println(producer.produce().name)
}
printAnimal(DogProducer()) // 공변성 덕분에 Producer<Dog>를 Producer<Animal>에 대입 가능

interface Consumer<in T> { fun consume(item: T) }
class AnimalConsumer : Consumer<Animal> {
    override fun consume(item: Animal) = println("Consumed: ${item.name}")
}
fun feedDog(consumer: Consumer<Dog>, dog: Dog) {
    consumer.consume(dog)
}
feedDog(AnimalConsumer(), Dog("Bori")) // 반공변성 덕분에 Consumer<Animal>을 Consumer<Dog>에 대입 가능

// [STAR Projection]
fun printFirst(list: List<*>) {
    println(list.firstOrNull())
}
printFirst(listOf(1, 2, 3))
printFirst(listOf("a", "b"))

// [reified 타입 파라미터]
inline fun <reified T> filterOfType(list: List<Any>): List<T> = list.filterIsInstance<T>()
val mixed = listOf(1, "hi", 2.0, "bye")
println(filterOfType<String>(mixed)) // [hi, bye]

inline fun <reified T> printTypeName() = println(T::class.simpleName)
printTypeName<Double>() // Double

// [타입 소거(Type Erasure) 한계]
fun <T> isString(value: Any): Boolean {
    // return value is T // 컴파일 에러: Cannot check for instance of erased type: T
    return false
}
// 해결: reified를 사용한 인라인 함수로 대체

// [실전: Number 타입만 받는 제네릭 스택]
class NumberStack<T : Number> {
    private val items = mutableListOf<T>()
    fun push(item: T) = items.add(item)
    fun pop(): T? = if (items.isNotEmpty()) items.removeAt(items.size - 1) else null
}
val stack = NumberStack<Int>()
stack.push(10)
stack.push(20)
println(stack.pop()) // 20

// [실전: 공변성/반공변성 실험]
val animalProducers: List<Producer<out Animal>> = listOf(DogProducer())
val animalConsumers: List<Consumer<in Dog>> = listOf(AnimalConsumer())

// [실전: reified로 런타임 타입 체크]
inline fun <reified T> findFirstOfType(list: List<Any>): T? = list.firstOrNull { it is T } as? T
println(findFirstOfType<String>(listOf(1, 2, "hello", 3.0))) // hello
```


---

#### 3단계: 실전 적용 및 디자인 패턴

- **컬렉션 프레임워크와 제네릭**
  - List<T>, Map<K, V>, Set<T> 등 코틀린의 컬렉션 프레임워크가 제네릭을 어떻게 활용하는지 분석합니다.
  - filterIsInstance<T>(), map<T, R>() 등 제네릭 기반의 컬렉션 함수 숙달

- **디자인 패턴에 제네릭 적용**
  - 팩토리(Factory): 다양한 타입의 객체를 생성하는 제네릭 팩토리 클래스
  - 빌더(Builder): 제네릭을 사용해 유연하게 객체를 구성하는 빌더 패턴
  - 옵저버(Observer): 제네릭으로 다양한 타입의 이벤트를 처리하는 옵저버 패턴
  - 싱글톤(Singleton): 여러 타입의 싱글톤 인스턴스를 관리하는 제네릭 싱글톤

- **델리게이트와 제네릭**
  - by 키워드를 사용한 델리게이션과 제네릭 결합으로 코드 재사용성 향상

- **자바와의 상호 운용성**
  - 자바 제네릭 코드와 코틀린 제네릭 코드 간의 타입 추론/안전성 문제, @JvmSuppressWildcards, @JvmWildcard 어노테이션 활용

- **추천 실습**
  - 다양한 메시지 타입을 처리할 수 있는 제네릭 이벤트 버스 구현
  - 제네릭 Builder 패턴으로 복잡한 객체 생성
  - 자바 제네릭 라이브러리를 코틀린에서 임포트해 타입 경고/에러 해결

```kotlin
// 제네릭 팩토리 예제
class Factory<T>(val creator: () -> T) { fun create() = creator() }
val stringFactory = Factory { "hello" }

// 제네릭 옵저버 예제
interface Observer<T> { fun onEvent(event: T) }

// 제네릭 Builder 예제
class Builder<T> {
    private val items = mutableListOf<T>()
    fun add(item: T): Builder<T> { items.add(item); return this }
    fun build(): List<T> = items
}
```

---

#### 4단계: 심화 학습 및 트러블슈팅

- **제네릭 관련 디자인 원칙**
  - API 설계 시 제네릭을 어떻게 활용해야 유연하고 안전한지 고민
  - 과도한 제네릭 사용은 오히려 코드 가독성 저하, 적절한 균형 필요

- **코틀린 표준 라이브러리 소스 분석**
  - kotlin.collections 패키지의 List, MutableList, kotlin.sequences, kotlin.coroutines 등에서 제네릭 활용 사례 분석

- **제네릭 사용 시 흔한 실수와 해결법**
  - ClassCastException 방지 (제네릭의 주 목적이지만 잘못 사용하면 발생)
  - 타입 소거로 인한 문제(reified 활용, 런타임 체크 추가)
  - 공변성/반공변성 오용 시 컴파일 에러 해결

- **추천 실습**
  - 자신만의 제네릭 유틸리티 함수/클래스 설계 및 구현
  - 코틀린 표준 라이브러리에서 제네릭이 많이 사용된 부분 분석 및 설계 이유 고민
  - 의도적으로 제네릭 관련 에러 발생→에러 메시지 읽고 디버깅

---

#### 학습 팁
- 이론 학습 후 즉시 실습: 개념만으로는 제네릭을 완전히 이해하기 어렵습니다. 직접 코드로 구현해보며 손에 익히세요.
- 다양한 예제 코드 분석: 코틀린 공식 문서, 오픈소스, 유명 라이브러리에서 제네릭 활용 사례를 찾아보세요.
- "왜?"라는 질문 던지기: 특정 문법/패턴이 왜 필요한지, 어떤 문제를 해결하는지 고민하세요.
- 점진적 학습: 쉬운 개념부터 차근차근 쌓아가세요.

---

> 코틀린 제네릭을 제대로 이해하면, 더 안전하고 유연하며 재사용성 높은 코드를 작성할 수 있습니다. 실습과 질문을 반복하며 자신만의 노하우를 쌓아보세요!
